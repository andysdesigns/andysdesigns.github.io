<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parametric Design Generator</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      display: flex;
      gap: 20px;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    .sidebar {
      width: 360px;
      display: flex;
      flex-direction: column;
      gap: 15px;
      overflow-y: auto;
      padding-left: 20px;
    }
    .content {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .sidebar table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .sidebar td {
      padding: 6px;
      vertical-align: middle;
    }
    .size-selector td:first-child,
    .controls-table td:first-child {
      width: 110px;
      font-weight: bold;
      text-align: left;
    }
    .pattern-selector td {
      padding: 4px;
      text-align: center;
      width: 33.33%;
    }
    .button-table td {
      padding: 4px;
    }
    .pattern-option {
      border: 2px solid #ddd;
      border-radius: 4px;
      padding: 6px;
      cursor: pointer;
      text-align: center;
      background-color: white;
    }
    .pattern-option.selected {
      border-color: #4a7bff;
      background-color: #f0f5ff;
    }
    .pattern-option svg {
      width: 50px;
      height: 50px;
      margin-bottom: 5px;
    }
    label {
      font-weight: bold;
      font-size: 14px;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
    }
    .slider {
      flex-grow: 1;
    }
    .value-display {
      width: 40px;
      text-align: center;
      font-weight: bold;
      font-size: 14px;
    }
    .svg-container {
      border: 1px solid #eee;
      background-color: white;
      position: relative;
    }
    button {
      background-color: #4a7bff;
      color: white;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      width: 100%;
    }
    button:hover {
      background-color: #3a6ae6;
    }
    button.secondary {
      background-color: #f0f0f0;
      color: #333;
      border: 1px solid #ddd;
    }
    button.secondary:hover {
      background-color: #e0e0e0;
    }
    select {
      background-color: transparent;
      color: #333;
      border: 1px solid #ddd;
      padding: 6px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      appearance: auto;
      width: 100%;
    }
    select:hover {
      border-color: #4a7bff;
    }
    input[type="number"] {
      background-color: #f0f0f0;
      color: #333;
      border: 1px solid #ddd;
      padding: 6px;
      border-radius: 4px;
      font-size: 14px;
      width: 100px;
    }
    input[type="number"]:hover:not(:disabled) {
      background-color: #e0e0e0;
    }
    input[type="number"]:disabled {
      background-color: #e0e0e0;
      cursor: not-allowed;
    }
    .custom-size-row {
      display: none;
    }
    .custom-size-row.active {
      display: table-row;
    }
    .color-picker-container {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    h1, h2 {
      margin: 0 0 10px;
      font-size: 24px;
    }
    h2 {
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="sidebar">
      <h2>Controls</h2>
      <!-- Size Selector Table -->
      <table class="size-selector">
        <tbody>
          <tr>
            <td><label for="paper-size">Paper Size:</label></td>
            <td>
              <select id="paper-size">
                <option value="a4" selected>A4 (210x297mm)</option>
                <option value="letter">Letter (8.5x11in)</option>
                <option value="a3">A3 (297x420mm)</option>
                <option value="square">Square (500x500px)</option>
                <option value="custom">Custom</option>
              </select>
            </td>
          </tr>
          <tr>
            <td><label for="orientation">Orientation:</label></td>
            <td>
              <select id="orientation">
                <option value="portrait" selected>Portrait</option>
                <option value="landscape">Landscape</option>
              </select>
            </td>
          </tr>
          <tr class="custom-size-row" id="custom-width-row">
            <td><label for="custom-width">Width (px):</label></td>
            <td><input type="number" id="custom-width" min="100" max="2000" value="500" disabled></td>
          </tr>
          <tr class="custom-size-row" id="custom-height-row">
            <td><label for="custom-height">Height (px):</label></td>
            <td><input type="number" id="custom-height" min="100" max="2000" value="500" disabled></td>
          </tr>
        </tbody>
      </table>
      <!-- Pattern Selector Table -->
      <table class="pattern-selector" id="pattern-selector">
        <tbody>
          <tr>
            <td>
              <div class="pattern-option selected" data-pattern="spirograph">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M0,15 A15,15 0 1,1 0,-15 A15,15 0 1,1 0,15" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                  <path d="M0,10 A10,10 0 1,1 0,-10 A10,10 0 1,1 0,10" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                  <path d="M0,20 A20,20 0 1,1 0,-20 A20,20 0 1,1 0,20" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Spirograph</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="polygon">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M0,20 L15,-10 L-15,-10 Z" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                  <path d="M0,15 L10,-5 L-10,-5 Z" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                  <path d="M0,10 L5,-2.5 L-5,-2.5 Z" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Polygon</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="lissajous">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M20,0 C20,10 10,20 0,20 C-10,20 -20,10 -20,0 C-20,-10 -10,-20 0,-20 C10,-20 20,-10 20,0 Z" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Lissajous</div>
              </div>
            </td>
          </tr>
          <tr>
            <td>
              <div class="pattern-option" data-pattern="rose">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M0,0 L15,0 M0,0 L7.5,13 M0,0 L-7.5,13 M0,0 L-15,0 M0,0 L-7.5,-13 M0,0 L7.5,-13" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Rose</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="hypotrochoid">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M15,0 A15,15 0 0,1 0,15 A15,15 0 0,1 -15,0 A15,15 0 0,1 0,-15 A15,15 0 0,1 15,0" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                  <path d="M10,0 A10,10 0 0,1 0,10 A10,10 0 0,1 -10,0 A10,10 0 0,1 0,-10 A10,10 0 0,1 10,0" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Hypotrochoid</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="epicycloid">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M15,0 C10,10 0,15 -10,10 C-15,0 -10,-10 0,-15 C10,-10 15,0 15,0" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Epicycloid</div>
              </div>
            </td>
          </tr>
          <tr>
            <td>
              <div class="pattern-option" data-pattern="fourier">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M0,0 C5,5 10,0 15,5 C10,10 5,5 0,10 C-5,5 -10,0 -15,5 C-10,10 -5,5 0,0" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Fourier Spiral</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="maurer">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M0,0 L15,0 M0,0 L7.5,13 M0,0 L-7.5,13 M0,0 L-15,0 M0,0 L7.5,-13" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Maurer Rose</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="superellipse">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M20,0 A20,20 0 0,1 0,20 A20,20 0 0,1 -20,0 A20,20 0 0,1 0,-20 A20,20 0 0,1 20,0" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Superellipse</div>
              </div>
            </td>
          </tr>
          <tr>
            <td>
              <div class="pattern-option" data-pattern="trochoid">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M10,0 A10,10 0 0,1 0,10 A10,10 0 0,1 -10,0 A10,10 0 0,1 0,-10 A10,10 0 0,1 10,0" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Trochoid Spiral</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="mandala">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M0,15 A15,15 0 0,1 15,0 A15,15 0 0,1 0,-15 A15,15 0 0,1 -15,0 A15,15 0 0,1 0,15" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                  <path d="M0,10 A10,10 0 0,1 10,0 A10,10 0 0,1 0,-10 A10,10 0 0,1 -10,0 A10,10 0 0,1 0,10" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Mandala</div>
              </div>
            </td>
            <td>
              <div class="pattern-option" data-pattern="butterfly">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M15,0 C10,10 -10,10 -15,0 C-10,-10 10,-10 15,0" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Butterfly Curve</div>
              </div>
            </td>
          </tr>
          <tr>
            <td>
              <div class="pattern-option" data-pattern="vortex">
                <svg width="50" height="50" viewBox="-25 -25 50 50">
                  <path d="M0,0 C5,5 10,0 15,5 C10,10 5,5 0,10 C-5,5 -10,0 -15,5 C-10,10 -5,5 0,15" fill="none" stroke="#ff3333" stroke-width="0.5"></path>
                </svg>
                <div>Vortex Spiral</div>
              </div>
            </td>
            <td></td>
            <td></td>
          </tr>
        </tbody>
      </table>
      <!-- Controls Table -->
      <table class="controls-table" id="controls-container">
        <tbody>
          <tr>
            <td><label for="color1">Color 1:</label></td>
            <td>
              <div class="color-picker-container">
                <input type="checkbox" id="color1-enable" checked>
                <input type="color" id="color1" value="#ff3333">
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="color2">Color 2:</label></td>
            <td>
              <div class="color-picker-container">
                <input type="checkbox" id="color2-enable" checked>
                <input type="color" id="color2" value="#33ff33">
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="color3">Color 3:</label></td>
            <td>
              <div class="color-picker-container">
                <input type="checkbox" id="color3-enable" checked>
                <input type="color" id="color3" value="#3333ff">
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="color4">Color 4:</label></td>
            <td>
              <div class="color-picker-container">
                <input type="checkbox" id="color4-enable">
                <input type="color" id="color4" value="#ff33ff">
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="color5">Color 5:</label></td>
            <td>
              <div class="color-picker-container">
                <input type="checkbox" id="color5-enable">
                <input type="color" id="color5" value="#ffff33">
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="background-color">Background:</label></td>
            <td>
              <input type="color" id="background-color" value="#ffffff">
            </td>
          </tr>
          <tr>
            <td><label for="opacity">Opacity:</label></td>
            <td>
              <div class="slider-container">
                <input type="range" id="opacity" class="slider" value="100" min="10" max="100" step="5">
                <span id="opacity-value" class="value-display">100%</span>
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="lineWidth">Line Width:</label></td>
            <td>
              <div class="slider-container">
                <input type="range" id="lineWidth" class="slider" value="0.5" min="0.1" max="3" step="0.1">
                <span id="lineWidth-value" class="value-display">0.5</span>
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="rotation">Rotation:</label></td>
            <td>
              <div class="slider-container">
                <input type="range" id="rotation" class="slider" value="0" min="0" max="360" step="5">
                <span id="rotation-value" class="value-display">0°</span>
              </div>
            </td>
          </tr>
          <tr>
            <td><label for="mutation">Mutation:</label></td>
            <td>
              <div class="slider-container">
                <input type="range" id="mutation" class="slider" value="0" min="0" max="1" step="0.1">
                <span id="mutation-value" class="value-display">0</span>
              </div>
            </td>
          </tr>
        </tbody>
      </table>
      <!-- Button Table -->
      <table class="button-table">
        <tbody>
          <tr>
            <td><button id="export-svg">Export SVG</button></td>
            <td><button id="randomize" class="secondary">Randomize</button></td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="content">
      <h1>Parametric Design Generator</h1>
      <div class="svg-container">
        <svg id="canvas" width="595" height="842" viewBox="-297.5 -421 595 842"></svg>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Paper size definitions (96 DPI: 1mm ≈ 3.78px, 1in ≈ 96px)
      const paperSizes = {
        a4: { width: 595, height: 842 },
        letter: { width: 816, height: 1056 },
        a3: { width: 842, height: 1191 },
        square: { width: 500, height: 500 },
        custom: { width: 500, height: 500 }
      };

      // Pattern definitions
      const patterns = {
        spirograph: {
          name: "Spirograph",
          params: [
            { id: "lobes", label: "Lobes", min: 1, max: 12, value: 3, step: 1 },
            { id: "points", label: "Points", min: 50, max: 1000, value: 300, step: 50 },
            { id: "innerRadius", label: "Inner Radius", min: 10, max: 200, value: 50, step: 5 },
            { id: "outerRadius", label: "Outer Radius", min: 20, max: 240, value: 150, step: 5 },
            { id: "density", label: "Line Density", min: 5, max: 100, value: 30, step: 5 }
          ],
          generate: function(params, svg) {
            const lobes = params.lobes * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const innerRadius = params.innerRadius * (1 + params.mutation * (Math.random() - 0.5));
            const outerRadius = params.outerRadius * (1 + params.mutation * (Math.random() - 0.5));
            const density = Math.round(params.density * (1 + params.mutation * (Math.random() - 0.5)));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let i = 0; i < density; i++) {
              const phase = (i / density) * 2 * Math.PI;
              const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let d = '';
              
              for (let j = 0; j <= points; j++) {
                const angle = (j / points) * 2 * Math.PI;
                const r = (innerRadius + (outerRadius - innerRadius) * 
                          (0.5 + 0.5 * Math.sin(lobes * angle + phase))) * scale;
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                d += j === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              line.setAttribute('d', d);
              line.setAttribute('fill', 'none');
              line.setAttribute('stroke', colors[i % colors.length]);
              line.setAttribute('stroke-width', lineWidth);
              line.setAttribute('stroke-opacity', opacity);
              g.appendChild(line);
            }
            svg.appendChild(g);
          }
        },
        polygon: {
          name: "Polygon Morph",
          params: [
            { id: "sides", label: "Sides", min: 3, max: 12, value: 6, step: 1 },
            { id: "layers", label: "Layers", min: 3, max: 50, value: 15, step: 1 },
            { id: "radius", label: "Max Radius", min: 50, max: 240, value: 200, step: 10 }
          ],
          generate: function(params, svg) {
            const sides = params.sides * (1 + params.mutation * (Math.random() - 0.5));
            const layers = Math.round(params.layers * (1 + params.mutation * (Math.random() - 0.5)));
            const maxRadius = params.radius * (1 + params.mutation * (Math.random() - 0.5));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let layer = 1; layer <= layers; layer++) {
              const radius = (layer / layers) * maxRadius * scale;
              const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
              let points = '';
              
              for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                points += `${x},${y} `;
              }
              
              polygon.setAttribute('points', points);
              polygon.setAttribute('fill', 'none');
              polygon.setAttribute('stroke', colors[layer % colors.length]);
              polygon.setAttribute('stroke-width', lineWidth);
              polygon.setAttribute('stroke-opacity', opacity);
              g.appendChild(polygon);
            }
            svg.appendChild(g);
          }
        },
        lissajous: {
          name: "Lissajous Curve",
          params: [
            { id: "freqX", label: "X Frequency", min: 1, max: 15, value: 3, step: 1 },
            { id: "freqY", label: "Y Frequency", min: 1, max: 15, value: 4, step: 1 },
            { id: "phaseShift", label: "Phase Shift", min: 0, max: 360, value: 90, step: 5 },
            { id: "iterations", label: "Iterations", min: 1, max: 20, value: 5, step: 1 },
            { id: "radius", label: "Radius", min: 50, max: 240, value: 200, step: 10 }
          ],
          generate: function(params, svg) {
            const freqX = params.freqX * (1 + params.mutation * (Math.random() - 0.5));
            const freqY = params.freqY * (1 + params.mutation * (Math.random() - 0.5));
            const phaseShift = params.phaseShift * (Math.PI / 180);
            const iterations = Math.round(params.iterations * (1 + params.mutation * (Math.random() - 0.5)));
            const radius = params.radius * (1 + params.mutation * (Math.random() - 0.5));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let i = 0; i < iterations; i++) {
              const phase = (i / iterations) * 2 * Math.PI;
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let d = '';
              
              const points = 1000;
              for (let j = 0; j <= points; j++) {
                const t = (j / points) * 2 * Math.PI;
                const x = (radius * Math.sin(freqX * t + phase)) * scale;
                const y = (radius * Math.sin(freqY * t + phaseShift + phase)) * scale;
                d += j === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', d);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[i % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        rose: {
          name: "Rose Curve",
          params: [
            { id: "k", label: "k value", min: 1, max: 10, value: 3, step: 0.5 },
            { id: "petals", label: "Petals", min: 1, max: 12, value: 5, step: 1 },
            { id: "layers", label: "Layers", min: 1, max: 20, value: 10, step: 1 },
            { id: "radius", label: "Max Radius", min: 50, max: 240, value: 200, step: 10 }
          ],
          generate: function(params, svg) {
            const k = params.k * (1 + params.mutation * (Math.random() - 0.5));
            const petals = params.petals * (1 + params.mutation * (Math.random() - 0.5));
            const layers = Math.round(params.layers * (1 + params.mutation * (Math.random() - 0.5)));
            const maxRadius = params.radius * (1 + params.mutation * (Math.random() - 0.5));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let layer = 1; layer <= layers; layer++) {
              const scaleFactor = (layer / layers) * maxRadius * scale;
              const phaseOffset = (layer / layers) * Math.PI / (petals * 2);
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let d = '';
              
              const points = 500;
              for (let j = 0; j <= points; j++) {
                const theta = (j / points) * 2 * Math.PI;
                const r = scaleFactor * Math.cos(k * theta + phaseOffset) * Math.cos(petals * theta);
                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);
                d += j === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', d);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[layer % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        hypotrochoid: {
          name: "Hypotrochoid",
          params: [
            { id: "R", label: "Outer Radius", min: 50, max: 240, value: 100, step: 5 },
            { id: "r", label: "Inner Radius", min: 10, max: 100, value: 30, step: 5 },
            { id: "d", label: "Distance", min: 10, max: 100, value: 50, step: 5 },
            { id: "points", label: "Points", min: 100, max: 2000, value: 1000, step: 50 },
            { id: "cycles", label: "Cycles", min: 1, max: 20, value: 5, step: 1 }
          ],
          generate: function(params, svg) {
            const R = params.R * (1 + params.mutation * (Math.random() - 0.5));
            const r = params.r * (1 + params.mutation * (Math.random() - 0.5));
            const d = params.d * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const cycles = Math.round(params.cycles * (1 + params.mutation * (Math.random() - 0.5)));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let c = 0; c < cycles; c++) {
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let dPath = '';
              
              for (let i = 0; i <= points; i++) {
                const t = (i / points) * cycles * 2 * Math.PI + (c * 2 * Math.PI / cycles);
                const x = ((R - r) * Math.cos(t) + d * Math.cos((R - r) / r * t)) * scale;
                const y = ((R - r) * Math.sin(t) - d * Math.sin((R - r) / r * t)) * scale;
                dPath += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', dPath);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[c % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        epicycloid: {
          name: "Epicycloid",
          params: [
            { id: "R", label: "Outer Radius", min: 50, max: 240, value: 100, step: 5 },
            { id: "r", label: "Rolling Radius", min: 10, max: 100, value: 30, step: 5 },
            { id: "points", label: "Points", min: 100, max: 2000, value: 1000, step: 50 },
            { id: "cycles", label: "Cycles", min: 1, max: 20, value: 5, step: 1 }
          ],
          generate: function(params, svg) {
            const R = params.R * (1 + params.mutation * (Math.random() - 0.5));
            const r = params.r * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const cycles = Math.round(params.cycles * (1 + params.mutation * (Math.random() - 0.5)));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let c = 0; c < cycles; c++) {
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let dPath = '';
              
              for (let i = 0; i <= points; i++) {
                const t = (i / points) * cycles * 2 * Math.PI + (c * 2 * Math.PI / cycles);
                const x = ((R + r) * Math.cos(t) - r * Math.cos((R + r) / r * t)) * scale;
                const y = ((R + r) * Math.sin(t) - r * Math.sin((R + r) / r * t)) * scale;
                dPath += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', dPath);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[c % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        fourier: {
          name: "Fourier Spiral",
          params: [
            { id: "n1", label: "Frequency 1", min: 1, max: 10, value: 2, step: 1 },
            { id: "n2", label: "Frequency 2", min: 1, max: 10, value: 3, step: 1 },
            { id: "a1", label: "Amplitude 1", min: 10, max: 100, value: 50, step: 5 },
            { id: "a2", label: "Amplitude 2", min: 10, max: 100, value: 30, step: 5 },
            { id: "points", label: "Points", min: 100, max: 2000, value: 1000, step: 50 },
            { id: "cycles", label: "Cycles", min: 1, max: 20, value: 5, step: 1 }
          ],
          generate: function(params, svg) {
            const n1 = params.n1 * (1 + params.mutation * (Math.random() - 0.5));
            const n2 = params.n2 * (1 + params.mutation * (Math.random() - 0.5));
            const a1 = params.a1 * (1 + params.mutation * (Math.random() - 0.5));
            const a2 = params.a2 * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const cycles = Math.round(params.cycles * (1 + params.mutation * (Math.random() - 0.5)));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let c = 0; c < cycles; c++) {
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let dPath = '';
              
              for (let i = 0; i <= points; i++) {
                const t = (i / points) * cycles * 2 * Math.PI + (c * 2 * Math.PI / cycles);
                const x = (a1 * Math.cos(n1 * t) + a2 * Math.cos(n2 * t)) * scale;
                const y = (a1 * Math.sin(n1 * t) + a2 * Math.sin(n2 * t)) * scale;
                dPath += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', dPath);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[c % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        maurer: {
          name: "Maurer Rose",
          params: [
            { id: "n", label: "Petal Factor", min: 1, max: 20, value: 6, step: 1 },
            { id: "d", label: "Angle Step", min: 1, max: 360, value: 71, step: 1 },
            { id: "radius", label: "Radius", min: 50, max: 240, value: 200, step: 10 },
            { id: "points", label: "Points", min: 100, max: 2000, value: 360, step: 10 }
          ],
          generate: function(params, svg) {
            const n = params.n * (1 + params.mutation * (Math.random() - 0.5));
            const d = params.d * (Math.PI / 180) * (1 + params.mutation * (Math.random() - 0.5));
            const radius = params.radius * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let c = 0; c < colors.length; c++) {
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let dPath = '';
              
              for (let i = 0; i <= points; i++) {
                const k = i * d + (c * 2 * Math.PI / colors.length);
                const r = radius * Math.sin(n * k) * scale;
                const x = r * Math.cos(k);
                const y = r * Math.sin(k);
                dPath += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', dPath);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[c]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        superellipse: {
          name: "Superellipse",
          params: [
            { id: "a", label: "Width", min: 50, max: 240, value: 200, step: 10 },
            { id: "b", label: "Height", min: 50, max: 240, value: 200, step: 10 },
            { id: "n", label: "Exponent", min: 0.5, max: 10, value: 2.5, step: 0.5 },
            { id: "points", label: "Points", min: 100, max: 2000, value: 1000, step: 50 },
            { id: "layers", label: "Layers", min: 1, max: 20, value: 5, step: 1 }
          ],
          generate: function(params, svg) {
            const a = params.a * (1 + params.mutation * (Math.random() - 0.5));
            const b = params.b * (1 + params.mutation * (Math.random() - 0.5));
            const n = params.n * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const layers = Math.round(params.layers * (1 + params.mutation * (Math.random() - 0.5)));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let layer = 1; layer <= layers; layer++) {
              const scaleFactor = (layer / layers) * scale;
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let dPath = '';
              
              for (let i = 0; i <= points; i++) {
                const t = (i / points) * 2 * Math.PI;
                const cosT = Math.cos(t);
                const sinT = Math.sin(t);
                const x = (a * Math.pow(Math.abs(cosT), 2 / n) * Math.sign(cosT)) * scaleFactor;
                const y = (b * Math.pow(Math.abs(sinT), 2 / n) * Math.sign(sinT)) * scaleFactor;
                dPath += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', dPath);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[layer % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        trochoid: {
          name: "Trochoid Spiral",
          params: [
            { id: "R", label: "Base Radius", min: 50, max: 240, value: 100, step: 5 },
            { id: "d", label: "Roll Distance", min: 10, max: 150, value: 50, step: 5 },
            { id: "points", label: "Points", min: 100, max: 2000, value: 1000, step: 50 },
            { id: "cycles", label: "Cycles", min: 1, max: 20, value: 5, step: 1 },
            { id: "spiral", label: "Spiral Factor", min: 0, max: 2, value: 0.5, step: 0.1 }
          ],
          generate: function(params, svg) {
            const R = params.R * (1 + params.mutation * (Math.random() - 0.5));
            const d = params.d * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const cycles = Math.round(params.cycles * (1 + params.mutation * (Math.random() - 0.5)));
            const spiral = params.spiral * (1 + params.mutation * (Math.random() - 0.5));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let c = 0; c < cycles; c++) {
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let dPath = '';
              
              for (let i = 0; i <= points; i++) {
                const t = (i / points) * cycles * 2 * Math.PI;
                const spiralFactor = 1 + spiral * (i / points);
                const x = (R * Math.cos(t) + d * Math.cos(t * 3) * spiralFactor) * scale;
                const y = (R * Math.sin(t) + d * Math.sin(t * 3) * spiralFactor) * scale;
                dPath += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', dPath);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[c % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        mandala: {
          name: "Mandala",
          params: [
            { id: "segments", label: "Segments", min: 4, max: 24, value: 12, step: 1 },
            { id: "layers", label: "Layers", min: 1, max: 10, value: 5, step: 1 },
            { id: "radius", label: "Max Radius", min: 50, max: 240, value: 200, step: 10 },
            { id: "complexity", label: "Complexity", min: 1, max: 5, value: 3, step: 1 }
          ],
          generate: function(params, svg) {
            const segments = Math.round(params.segments * (1 + params.mutation * (Math.random() - 0.5)));
            const layers = Math.round(params.layers * (1 + params.mutation * (Math.random() - 0.5)));
            const maxRadius = params.radius * (1 + params.mutation * (Math.random() - 0.5));
            const complexity = Math.round(params.complexity * (1 + params.mutation * (Math.random() - 0.5)));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let layer = 1; layer <= layers; layer++) {
              const radius = (layer / layers) * maxRadius * scale;
              for (let j = 0; j < complexity; j++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';
                const innerRadius = radius * (1 - (j + 1) / (complexity + 1));
                
                for (let i = 0; i <= segments; i++) {
                  const angle = (i / segments) * 2 * Math.PI;
                  const r = i % 2 === 0 ? radius : innerRadius;
                  const x = r * Math.cos(angle);
                  const y = r * Math.sin(angle);
                  d += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
                }
                d += 'Z';
                
                path.setAttribute('d', d);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', colors[(layer + j) % colors.length]);
                path.setAttribute('stroke-width', lineWidth);
                path.setAttribute('stroke-opacity', opacity);
                g.appendChild(path);
              }
            }
            svg.appendChild(g);
          }
        },
        butterfly: {
          name: "Butterfly Curve",
          params: [
            { id: "scaleFactor", label: "Scale Factor", min: 10, max: 200, value: 100, step: 5 },
            { id: "points", label: "Points", min: 100, max: 5000, value: 2000, step: 100 },
            { id: "cycles", label: "Cycles", min: 1, max: 10, value: 4, step: 1 },
            { id: "complexity", label: "Complexity", min: 1, max: 5, value: 2, step: 1 },
            { id: "offset", label: "Offset", min: 0, max: 360, value: 0, step: 5 }
          ],
          generate: function(params, svg) {
            const scaleFactor = params.scaleFactor * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const cycles = Math.round(params.cycles * (1 + params.mutation * (Math.random() - 0.5)));
            const complexity = Math.round(params.complexity * (1 + params.mutation * (Math.random() - 0.5)));
            const offset = params.offset * (Math.PI / 180);
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let c = 0; c < complexity; c++) {
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let d = '';
              
              for (let i = 0; i <= points; i++) {
                const t = (i / points) * cycles * 2 * Math.PI;
                const r = scaleFactor * Math.sin(t) * (
                  Math.pow(Math.E, Math.cos(t)) - 
                  2 * Math.cos(4 * t) - 
                  Math.pow(Math.sin(t / 12), 5)
                );
                const x = r * Math.cos(t + offset + c * Math.PI / complexity) * scale;
                const y = r * Math.sin(t + offset + c * Math.PI / complexity) * scale;
                d += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', d);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[c % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        },
        vortex: {
          name: "Vortex Spiral",
          params: [
            { id: "arms", label: "Arms", min: 1, max: 12, value: 4, step: 1 },
            { id: "decay", label: "Decay Rate", min: 0.1, max: 2, value: 0.5, step: 0.1 },
            { id: "points", label: "Points", min: 100, max: 2000, value: 1000, step: 50 },
            { id: "radius", label: "Max Radius", min: 50, max: 240, value: 200, step: 10 },
            { id: "twist", label: "Twist", min: 0, max: 5, value: 2, step: 0.1 }
          ],
          generate: function(params, svg) {
            const arms = Math.round(params.arms * (1 + params.mutation * (Math.random() - 0.5)));
            const decay = params.decay * (1 + params.mutation * (Math.random() - 0.5));
            const points = params.points;
            const maxRadius = params.radius * (1 + params.mutation * (Math.random() - 0.5));
            const twist = params.twist * (1 + params.mutation * (Math.random() - 0.5));
            const colors = params.colors;
            const opacity = params.opacity / 100;
            const lineWidth = params.lineWidth;
            const scale = params.scale || 1;
            const rotation = params.rotation * (Math.PI / 180);
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 180 / Math.PI})`);
            
            for (let arm = 0; arm < arms; arm++) {
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              let d = '';
              const phase = (arm / arms) * 2 * Math.PI;
              
              for (let i = 0; i <= points; i++) {
                const t = (i / points) * 4 * Math.PI;
                const r = maxRadius * Math.exp(-decay * t) * scale;
                const theta = t * twist + phase;
                const x = r * Math.cos(theta);
                const y = r * Math.sin(theta);
                d += i === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
              }
              
              path.setAttribute('d', d);
              path.setAttribute('fill', 'none');
              path.setAttribute('stroke', colors[arm % colors.length]);
              path.setAttribute('stroke-width', lineWidth);
              path.setAttribute('stroke-opacity', opacity);
              g.appendChild(path);
            }
            svg.appendChild(g);
          }
        }
      };

      let currentPattern = 'spirograph';
      let currentParams = {};

      // DOM elements
      const paperSizeSelect = document.getElementById('paper-size');
      const orientationSelect = document.getElementById('orientation');
      const customWidthRow = document.getElementById('custom-width-row');
      const customHeightRow = document.getElementById('custom-height-row');
      const customWidthInput = document.getElementById('custom-width');
      const customHeightInput = document.getElementById('custom-height');
      const canvas = document.getElementById('canvas');
      const controlsContainer = document.getElementById('controls-container');

      // Validate DOM elements
      if (!paperSizeSelect || !orientationSelect || !customWidthRow || !customHeightRow || 
          !customWidthInput || !customHeightInput || !canvas || !controlsContainer) {
        console.error('Missing critical DOM elements');
        return;
      }

      // Toggle custom size inputs
      function toggleCustomSize() {
        const isCustom = paperSizeSelect.value === 'custom';
        customWidthRow.classList.toggle('active', isCustom);
        customHeightRow.classList.toggle('active', isCustom);
        customWidthInput.disabled = !isCustom;
        customHeightInput.disabled = !isCustom;
      }

      // Update canvas size
      function updateCanvasSize() {
        const size = paperSizeSelect.value;
        const orientation = orientationSelect.value;
        let width, height;

        if (size === 'custom') {
          width = parseInt(customWidthInput.value) || 500;
          height = parseInt(customHeightInput.value) || 500;
          width = Math.max(100, Math.min(2000, width));
          height = Math.max(100, Math.min(2000, height));
        } else {
          width = paperSizes[size].width;
          height = paperSizes[size].height;
        }

        if (orientation === 'landscape' && size !== 'square') {
          [width, height] = [height, width];
        }

        canvas.setAttribute('width', width);
        canvas.setAttribute('height', height);
        canvas.setAttribute('viewBox', `-${width/2} -${height/2} ${width} ${height}`);
      }

      // Collect parameters
      function collectParameters() {
        const params = {};
        params.colors = [];
        for (let i = 1; i <= 5; i++) {
          const enableCheckbox = document.getElementById(`color${i}-enable`);
          if (enableCheckbox?.checked) {
            const colorInput = document.getElementById(`color${i}`);
            if (colorInput) {
              params.colors.push(colorInput.value);
            }
          }
        }
        if (params.colors.length === 0) {
          params.colors.push('#ff3333'); // Fallback color
        }
        params.backgroundColor = document.getElementById('background-color')?.value || '#ffffff';
        params.opacity = parseInt(document.getElementById('opacity')?.value || 100);
        params.lineWidth = parseFloat(document.getElementById('lineWidth')?.value || 0.5);
        params.rotation = parseInt(document.getElementById('rotation')?.value || 0);
        params.mutation = parseFloat(document.getElementById('mutation')?.value || 0);

        patterns[currentPattern].params.forEach(param => {
          const element = document.getElementById(param.id);
          if (element) {
            params[param.id] = param.step < 1 ? parseFloat(element.value) : parseInt(element.value);
          }
        });

        const width = parseInt(canvas.getAttribute('width'));
        const height = parseInt(canvas.getAttribute('height'));
        params.scale = Math.min(width, height) / 500;

        return params;
      }

      // Generate curve
      function generateCurve() {
        while (canvas.firstChild) {
          canvas.removeChild(canvas.firstChild);
        }

        const params = collectParameters();

        // Add background
        const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        const width = parseInt(canvas.getAttribute('width'));
        const height = parseInt(canvas.getAttribute('height'));
        background.setAttribute('x', -width / 2);
        background.setAttribute('y', -height / 2);
        background.setAttribute('width', width);
        background.setAttribute('height', height);
        background.setAttribute('fill', params.backgroundColor);
        canvas.appendChild(background);

        // Generate pattern
        if (patterns[currentPattern]) {
          patterns[currentPattern].generate(params, canvas);
        } else {
          console.error('Invalid pattern:', currentPattern);
        }
      }

      // Setup controls
      function setupControls(patternName) {
        currentParams = {};
        const tbody = controlsContainer.querySelector('tbody');

        // Preserve common controls
        const commonControls = [
          'color1', 'color1-enable', 'color2', 'color2-enable', 'color3', 'color3-enable',
          'color4', 'color4-enable', 'color5', 'color5-enable', 'background-color',
          'opacity', 'lineWidth', 'rotation', 'mutation'
        ];
        Array.from(tbody.children).forEach(row => {
          const input = row.querySelector('input');
          if (input && !commonControls.includes(input.id)) {
            row.remove();
          }
        });

        // Add pattern-specific controls
        patterns[patternName].params.forEach(param => {
          if (document.getElementById(param.id)) return;

          const tr = document.createElement('tr');
          const labelTd = document.createElement('td');
          const label = document.createElement('label');
          label.setAttribute('for', param.id);
          label.textContent = `${param.label}:`;
          labelTd.appendChild(label);
          tr.appendChild(labelTd);

          const inputTd = document.createElement('td');
          const sliderContainer = document.createElement('div');
          sliderContainer.className = 'slider-container';

          const slider = document.createElement('input');
          slider.type = 'range';
          slider.id = param.id;
          slider.className = 'slider';
          slider.min = param.min;
          slider.max = param.max;
          slider.value = param.value;
          slider.step = param.step;

          const valueDisplay = document.createElement('span');
          valueDisplay.id = `${param.id}-value`;
          valueDisplay.className = 'value-display';
          valueDisplay.textContent = param.value;

          sliderContainer.appendChild(slider);
          sliderContainer.appendChild(valueDisplay);
          inputTd.appendChild(sliderContainer);
          tr.appendChild(inputTd);
          tbody.appendChild(tr);

          slider.addEventListener('input', () => {
            valueDisplay.textContent = slider.value;
            generateCurve();
          });

          currentParams[param.id] = param.value;
        });

        // Setup common controls
        commonControls.forEach(id => {
          const element = document.getElementById(id);
          if (!element) return;
          element.removeEventListener('input', generateCurve);
          element.removeEventListener('change', generateCurve);

          if (id === 'opacity') {
            document.getElementById('opacity-value').textContent = `${element.value}%`;
            element.addEventListener('input', () => {
              document.getElementById('opacity-value').textContent = `${element.value}%`;
              generateCurve();
            });
          } else if (id === 'lineWidth') {
            document.getElementById('lineWidth-value').textContent = element.value;
            element.addEventListener('input', () => {
              document.getElementById('lineWidth-value').textContent = element.value;
              generateCurve();
            });
          } else if (id === 'rotation') {
            document.getElementById('rotation-value').textContent = `${element.value}°`;
            element.addEventListener('input', () => {
              document.getElementById('rotation-value').textContent = `${element.value}°`;
              generateCurve();
            });
          } else if (id === 'mutation') {
            document.getElementById('mutation-value').textContent = element.value;
            element.addEventListener('input', () => {
              document.getElementById('mutation-value').textContent = element.value;
              generateCurve();
            });
          } else if (id.includes('color') && !id.includes('enable')) {
            element.addEventListener('input', generateCurve);
          } else if (id.includes('enable')) {
            element.addEventListener('change', generateCurve);
          } else if (id === 'background-color') {
            element.addEventListener('input', generateCurve);
          }
        });
      }

      // Export SVG
      function exportSVG() {
        const params = collectParameters();
        const zip = new JSZip();
        const patternName = patterns[currentPattern].name.toLowerCase().replace(/\s+/g, '-');

        // Full SVG
        const fullSvgData = new XMLSerializer().serializeToString(canvas);
        zip.file(`${patternName}.svg`, fullSvgData);

        // Per-color SVGs
        if (params.colors.length > 1) {
          params.colors.forEach((color, index) => {
            const tempSvg = canvas.cloneNode(true);
            const paths = tempSvg.querySelectorAll('path');
            paths.forEach(path => {
              if (path.getAttribute('stroke').toLowerCase() !== color.toLowerCase()) {
                path.remove();
              }
            });
            const colorSvgData = new XMLSerializer().serializeToString(tempSvg);
            zip.file(`${patternName}-color${index + 1}.svg`, colorSvgData);
          });
        }

        // Generate ZIP
        zip.generateAsync({ type: 'blob' }).then(blob => {
          const zipUrl = URL.createObjectURL(blob);
          const downloadLink = document.createElement('a');
          downloadLink.href = zipUrl;
          downloadLink.download = `${patternName}.zip`;
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          setTimeout(() => URL.revokeObjectURL(zipUrl), 100);
        });
      }

      // Randomize parameters
      function randomizeParameters() {
        patterns[currentPattern].params.forEach(param => {
          const element = document.getElementById(param.id);
          if (element) {
            const range = param.max - param.min;
            const randomValue = param.min + Math.random() * range;
            const stepValue = Math.round(randomValue / param.step) * param.step;
            const finalValue = Math.max(param.min, Math.min(param.max, stepValue));
            element.value = finalValue;
            document.getElementById(`${param.id}-value`).textContent = finalValue;
          }
        });

        const rotationSlider = document.getElementById('rotation');
        if (rotationSlider) {
          rotationSlider.value = Math.round(Math.random() * 360 / 5) * 5;
          document.getElementById('rotation-value').textContent = `${rotationSlider.value}°`;
        }

        const mutationSlider = document.getElementById('mutation');
        if (mutationSlider) {
          mutationSlider.value = Math.random().toFixed(1);
          document.getElementById('mutation-value').textContent = mutationSlider.value;
        }

        // Randomize color enables (at least one color enabled)
        const colorEnables = Array(5).fill(false);
        colorEnables[0] = true; // Ensure at least one color
        for (let i = 1; i < 5; i++) {
          colorEnables[i] = Math.random() > 0.5;
        }
        for (let i = 1; i <= 5; i++) {
          const enableCheckbox = document.getElementById(`color${i}-enable`);
          if (enableCheckbox) {
            enableCheckbox.checked = colorEnables[i - 1];
          }
        }

        generateCurve();
      }

      // Initialize
      setupControls(currentPattern);
      toggleCustomSize();
      updateCanvasSize();
      generateCurve();

      // Event listeners
      paperSizeSelect.addEventListener('change', () => {
        toggleCustomSize();
        updateCanvasSize();
        generateCurve();
      });

      orientationSelect.addEventListener('change', () => {
        updateCanvasSize();
        generateCurve();
      });

      customWidthInput.addEventListener('input', () => {
        if (!customWidthInput.disabled) {
          updateCanvasSize();
          generateCurve();
        }
      });

      customHeightInput.addEventListener('input', () => {
        if (!customHeightInput.disabled) {
          updateCanvasSize();
          generateCurve();
        }
      });

      document.getElementById('export-svg').addEventListener('click', exportSVG);
      document.getElementById('randomize').addEventListener('click', randomizeParameters);

      // Pattern selection
      document.querySelectorAll('.pattern-option').forEach(option => {
        option.addEventListener('click', () => {
          document.querySelectorAll('.pattern-option').forEach(o => o.classList.remove('selected'));
          option.classList.add('selected');
          currentPattern = option.getAttribute('data-pattern');
          setupControls(currentPattern);
          generateCurve();
        });
      });
    });
  </script>
</body>
</html>
